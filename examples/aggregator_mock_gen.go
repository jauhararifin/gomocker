// Code generated by gomocker github.com/jauhararifin/gomocker. DO NOT EDIT.

package examples

import "sync"

type AggregatorMocker struct {
	SumInt *Aggregator_SumIntMocker
}

type MockedAggregator struct {
	mocker *AggregatorMocker
}

func (m *MockedAggregator) SumInt(vals ...int) (out1 int) {
	return m.mocker.SumInt.Call(vals...)
}

func NewMockedAggregator() (*MockedAggregator, *AggregatorMocker) {
	m := &AggregatorMocker{SumInt: &Aggregator_SumIntMocker{}}
	return &MockedAggregator{m}, m
}

type Aggregator_SumIntMocker struct {
	mux         sync.Mutex
	handlers    []func(vals ...int) int
	lifetimes   []int
	invocations []struct {
		Inputs struct {
			Vals []int
		}
		Outputs struct {
			Out1 int
		}
	}
}

func (m *Aggregator_SumIntMocker) Mock(nTimes int, f func(vals ...int) int) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Aggregator_SumIntMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Aggregator_SumIntMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Aggregator_SumIntMocker) MockOnce(f func(vals ...int) int) {
	m.Mock(1, f)
}

func (m *Aggregator_SumIntMocker) MockForever(f func(vals ...int) int) {
	m.Mock(0, f)
}

func (m *Aggregator_SumIntMocker) MockOutputs(nTimes int, out1 int) {
	m.Mock(nTimes, func(vals ...int) int {
		return out1
	})
}

func (m *Aggregator_SumIntMocker) MockOutputsOnce(out1 int) {
	m.MockOutputs(1, out1)
}

func (m *Aggregator_SumIntMocker) MockOutputsForever(out1 int) {
	m.MockOutputs(0, out1)
}

func (m *Aggregator_SumIntMocker) MockDefaults(nTimes int) {
	var out1 int
	m.MockOutputs(nTimes, out1)
}

func (m *Aggregator_SumIntMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Aggregator_SumIntMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Aggregator_SumIntMocker) Call(vals ...int) (out1 int) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Aggregator_SumIntMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1 = handler(vals...)
	input := struct {
		Vals []int
	}{vals}
	output := struct {
		Out1 int
	}{out1}
	invoc := struct {
		Inputs struct {
			Vals []int
		}
		Outputs struct {
			Out1 int
		}
	}{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1
}

func (m *Aggregator_SumIntMocker) Invocations() []struct {
	Inputs struct {
		Vals []int
	}
	Outputs struct {
		Out1 int
	}
} {
	return m.invocations
}

func (m *Aggregator_SumIntMocker) TakeOneInvocation() struct {
	Inputs struct {
		Vals []int
	}
	Outputs struct {
		Out1 int
	}
} {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Aggregator_SumIntMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}
