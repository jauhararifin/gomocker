// Code generated by gomocker github.com/jauhararifin/gomocker. DO NOT EDIT.

package examples

import (
	"context"
	"sync"
)

type ComplicatedMocker struct {
	MethodA *Complicated_MethodAMocker
	MethodB *Complicated_MethodBMocker
}

type MockedComplicated struct {
	mocker *ComplicatedMocker
}

func (m *MockedComplicated) MethodA(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int) {
	return m.mocker.MethodA.Call(ctx, param1, param2...)
}
func (m *MockedComplicated) MethodB(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	return m.mocker.MethodB.Call(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

func NewMockedComplicated() (*MockedComplicated, *ComplicatedMocker) {
	m := &ComplicatedMocker{MethodA: &Complicated_MethodAMocker{}, MethodB: &Complicated_MethodBMocker{}}
	return &MockedComplicated{m}, m
}

type Complicated_MethodAInvocation struct {
	Inputs struct {
		Ctx    context.Context
		Param1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Param2 []struct {
			A func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			B func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			C func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
		}
	}
	Outputs struct {
		Out1 int
		Out2 int
		Out3 []int
	}
}

type Complicated_MethodAMocker struct {
	mux      sync.Mutex
	handlers []func(context.Context, interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}, ...struct {
		A func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
		B func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
		C func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
	}) (int, int, []int)
	lifetimes   []int
	invocations []Complicated_MethodAInvocation
}

func (m *Complicated_MethodAMocker) Mock(nTimes int, f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Complicated_MethodAMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Complicated_MethodAMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Complicated_MethodAMocker) MockOnce(f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.Mock(1, f)
}

func (m *Complicated_MethodAMocker) MockForever(f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.Mock(0, f)
}

func (m *Complicated_MethodAMocker) MockOutputs(nTimes int, out1 int, out2 int, out3 []int) {
	m.Mock(nTimes, func(context.Context, interface {
		Param1Method1(arg1 ...int) (out1 int, out2 error)
		Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
	}, ...struct {
		A func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
		B func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
		C func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
	}) (int, int, []int) {
		return out1, out2, out3
	})
}

func (m *Complicated_MethodAMocker) MockOutputsOnce(out1 int, out2 int, out3 []int) {
	m.MockOutputs(1, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockOutputsForever(out1 int, out2 int, out3 []int) {
	m.MockOutputs(0, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 int
	var out3 []int
	m.MockOutputs(nTimes, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Complicated_MethodAMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Complicated_MethodAMocker) Call(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Complicated_MethodAMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2, out3 = handler(ctx, param1, param2...)
	input := struct {
		Ctx    context.Context
		Param1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Param2 []struct {
			A func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			B func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			C func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
		}
	}{ctx, param1, param2}
	output := struct {
		Out1 int
		Out2 int
		Out3 []int
	}{out1, out2, out3}
	invoc := Complicated_MethodAInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2, out3
}

func (m *Complicated_MethodAMocker) Invocations() []Complicated_MethodAInvocation {
	return m.invocations
}

func (m *Complicated_MethodAMocker) TakeOneInvocation() Complicated_MethodAInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Complicated_MethodAMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type Complicated_MethodBInvocation struct {
	Inputs struct {
		Arg1 chan int
		Arg2 <-chan int
		Arg3 chan<- int
		Arg4 []int
		Arg5 [10]int
		Arg6 map[int]struct{}
		Arg7 map[int]string
		Arg8 map[int]struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}
	Outputs struct {
		Out1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Out2 struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}
}

type Complicated_MethodBMocker struct {
	mux      sync.Mutex
	handlers []func(chan int, <-chan int, chan<- int, []int, [10]int, map[int]struct{}, map[int]string, map[int]struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	}) (interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}, struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	})
	lifetimes   []int
	invocations []Complicated_MethodBInvocation
}

func (m *Complicated_MethodBMocker) Mock(nTimes int, f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Complicated_MethodBMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Complicated_MethodBMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Complicated_MethodBMocker) MockOnce(f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.Mock(1, f)
}

func (m *Complicated_MethodBMocker) MockForever(f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.Mock(0, f)
}

func (m *Complicated_MethodBMocker) MockOutputs(nTimes int, out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.Mock(nTimes, func(chan int, <-chan int, chan<- int, []int, [10]int, map[int]struct{}, map[int]string, map[int]struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	}) (interface {
		Param1Method1(arg1 ...int) (out1 int, out2 error)
		Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
	}, struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	}) {
		return out1, out2
	})
}

func (m *Complicated_MethodBMocker) MockOutputsOnce(out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.MockOutputs(1, out1, out2)
}

func (m *Complicated_MethodBMocker) MockOutputsForever(out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.MockOutputs(0, out1, out2)
}

func (m *Complicated_MethodBMocker) MockDefaults(nTimes int) {
	var out1 interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}
	var out2 struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	}
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Complicated_MethodBMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Complicated_MethodBMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Complicated_MethodBMocker) Call(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Complicated_MethodBMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 = handler(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	input := struct {
		Arg1 chan int
		Arg2 <-chan int
		Arg3 chan<- int
		Arg4 []int
		Arg5 [10]int
		Arg6 map[int]struct{}
		Arg7 map[int]string
		Arg8 map[int]struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}
	output := struct {
		Out1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Out2 struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}{out1, out2}
	invoc := Complicated_MethodBInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Complicated_MethodBMocker) Invocations() []Complicated_MethodBInvocation {
	return m.invocations
}

func (m *Complicated_MethodBMocker) TakeOneInvocation() Complicated_MethodBInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Complicated_MethodBMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}
