// Code generated by gomocker github.com/jauhararifin/gomocker. DO NOT EDIT.

package examples

import (
	"context"
	"sync"
)

type AddFuncInvocation struct {
	Inputs struct {
		Ctx context.Context
		A   int
		B   int
	}
	Outputs struct {
		Sum int
		Err error
	}
}

type AddFuncMocker struct {
	mux         sync.Mutex
	handlers    []func(context.Context, int, int) (int, error)
	lifetimes   []int
	invocations []AddFuncInvocation
}

func (m *AddFuncMocker) Mock(nTimes int, f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("AddFuncMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("AddFuncMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *AddFuncMocker) MockOnce(f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.Mock(1, f)
}

func (m *AddFuncMocker) MockForever(f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.Mock(0, f)
}

func (m *AddFuncMocker) MockOutputs(nTimes int, sum int, err error) {
	m.Mock(nTimes, func(context.Context, int, int) (int, error) {
		return sum, err
	})
}

func (m *AddFuncMocker) MockOutputsOnce(sum int, err error) {
	m.MockOutputs(1, sum, err)
}

func (m *AddFuncMocker) MockOutputsForever(sum int, err error) {
	m.MockOutputs(0, sum, err)
}

func (m *AddFuncMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *AddFuncMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *AddFuncMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *AddFuncMocker) Call(ctx context.Context, a int, b int) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("AddFuncMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(ctx, a, b)
	input := struct {
		Ctx context.Context
		A   int
		B   int
	}{ctx, a, b}
	output := struct {
		Sum int
		Err error
	}{out1, out2}
	invoc := AddFuncInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *AddFuncMocker) Invocations() []AddFuncInvocation {
	return m.invocations
}

func (m *AddFuncMocker) TakeOneInvocation() AddFuncInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("AddFuncMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

func NewMockedAddFunc() (func(context.Context, int, int) (int, error), *AddFuncMocker) {
	m := &AddFuncMocker{}
	return m.Call, m
}

type AggregatorMocker struct {
	SumInt *Aggregator_SumIntMocker
}

type MockedAggregator struct {
	mocker *AggregatorMocker
}

func (m *MockedAggregator) SumInt(vals ...int) (out1 int) {
	return m.mocker.SumInt.Call(vals...)
}

func NewMockedAggregator() (*MockedAggregator, *AggregatorMocker) {
	m := &AggregatorMocker{SumInt: &Aggregator_SumIntMocker{}}
	return &MockedAggregator{m}, m
}

type Aggregator_SumIntInvocation struct {
	Inputs struct {
		Vals []int
	}
	Outputs struct {
		Out1 int
	}
}

type Aggregator_SumIntMocker struct {
	mux         sync.Mutex
	handlers    []func(...int) int
	lifetimes   []int
	invocations []Aggregator_SumIntInvocation
}

func (m *Aggregator_SumIntMocker) Mock(nTimes int, f func(vals ...int) (out1 int)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Aggregator_SumIntMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Aggregator_SumIntMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Aggregator_SumIntMocker) MockOnce(f func(vals ...int) (out1 int)) {
	m.Mock(1, f)
}

func (m *Aggregator_SumIntMocker) MockForever(f func(vals ...int) (out1 int)) {
	m.Mock(0, f)
}

func (m *Aggregator_SumIntMocker) MockOutputs(nTimes int, out1 int) {
	m.Mock(nTimes, func(...int) int {
		return out1
	})
}

func (m *Aggregator_SumIntMocker) MockOutputsOnce(out1 int) {
	m.MockOutputs(1, out1)
}

func (m *Aggregator_SumIntMocker) MockOutputsForever(out1 int) {
	m.MockOutputs(0, out1)
}

func (m *Aggregator_SumIntMocker) MockDefaults(nTimes int) {
	var out1 int
	m.MockOutputs(nTimes, out1)
}

func (m *Aggregator_SumIntMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Aggregator_SumIntMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Aggregator_SumIntMocker) Call(vals ...int) int {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Aggregator_SumIntMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1 := handler(vals...)
	input := struct {
		Vals []int
	}{vals}
	output := struct {
		Out1 int
	}{out1}
	invoc := Aggregator_SumIntInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1
}

func (m *Aggregator_SumIntMocker) Invocations() []Aggregator_SumIntInvocation {
	return m.invocations
}

func (m *Aggregator_SumIntMocker) TakeOneInvocation() Aggregator_SumIntInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Aggregator_SumIntMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type ComplicatedMocker struct {
	MethodA *Complicated_MethodAMocker
	MethodB *Complicated_MethodBMocker
}

type MockedComplicated struct {
	mocker *ComplicatedMocker
}

func (m *MockedComplicated) MethodA(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int) {
	return m.mocker.MethodA.Call(ctx, param1, param2...)
}
func (m *MockedComplicated) MethodB(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	return m.mocker.MethodB.Call(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

func NewMockedComplicated() (*MockedComplicated, *ComplicatedMocker) {
	m := &ComplicatedMocker{MethodA: &Complicated_MethodAMocker{}, MethodB: &Complicated_MethodBMocker{}}
	return &MockedComplicated{m}, m
}

type Complicated_MethodAInvocation struct {
	Inputs struct {
		Ctx    context.Context
		Param1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Param2 []struct {
			A func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			B func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			C func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
		}
	}
	Outputs struct {
		Out1 int
		Out2 int
		Out3 []int
	}
}

type Complicated_MethodAMocker struct {
	mux      sync.Mutex
	handlers []func(context.Context, interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}, ...struct {
		A func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
		B func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
		C func(context.Context, struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		})
	}) (int, int, []int)
	lifetimes   []int
	invocations []Complicated_MethodAInvocation
}

func (m *Complicated_MethodAMocker) Mock(nTimes int, f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Complicated_MethodAMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Complicated_MethodAMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Complicated_MethodAMocker) MockOnce(f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.Mock(1, f)
}

func (m *Complicated_MethodAMocker) MockForever(f func(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (out1 int, out2 int, out3 []int)) {
	m.Mock(0, f)
}

func (m *Complicated_MethodAMocker) MockOutputs(nTimes int, out1 int, out2 int, out3 []int) {
	m.Mock(nTimes, func(context.Context, interface {
		Param1Method1(arg1 ...int) (out1 int, out2 error)
		Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
	}, ...struct {
		A func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
		B func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
		C func(ctx2 context.Context, param2 struct {
			A int
			B int
			C int
			D func() (out1 interface {
				A() (out1 error)
			})
			E func() (out1 interface {
				A() (out1 error)
			})
			F func() (out1 interface {
				A() (out1 error)
			})
		})
	}) (int, int, []int) {
		return out1, out2, out3
	})
}

func (m *Complicated_MethodAMocker) MockOutputsOnce(out1 int, out2 int, out3 []int) {
	m.MockOutputs(1, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockOutputsForever(out1 int, out2 int, out3 []int) {
	m.MockOutputs(0, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 int
	var out3 []int
	m.MockOutputs(nTimes, out1, out2, out3)
}

func (m *Complicated_MethodAMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Complicated_MethodAMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Complicated_MethodAMocker) Call(ctx context.Context, param1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, param2 ...struct {
	A func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	B func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
	C func(ctx2 context.Context, param2 struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	})
}) (int, int, []int) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Complicated_MethodAMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2, out3 := handler(ctx, param1, param2...)
	input := struct {
		Ctx    context.Context
		Param1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Param2 []struct {
			A func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			B func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
			C func(context.Context, struct {
				A int
				B int
				C int
				D func() interface {
					A() error
				}
				E func() interface {
					A() error
				}
				F func() interface {
					A() error
				}
			})
		}
	}{ctx, param1, param2}
	output := struct {
		Out1 int
		Out2 int
		Out3 []int
	}{out1, out2, out3}
	invoc := Complicated_MethodAInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2, out3
}

func (m *Complicated_MethodAMocker) Invocations() []Complicated_MethodAInvocation {
	return m.invocations
}

func (m *Complicated_MethodAMocker) TakeOneInvocation() Complicated_MethodAInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Complicated_MethodAMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type Complicated_MethodBInvocation struct {
	Inputs struct {
		Arg1 chan int
		Arg2 <-chan int
		Arg3 chan<- int
		Arg4 []int
		Arg5 [10]int
		Arg6 map[int]struct{}
		Arg7 map[int]string
		Arg8 map[int]struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}
	Outputs struct {
		Out1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Out2 struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}
}

type Complicated_MethodBMocker struct {
	mux      sync.Mutex
	handlers []func(chan int, <-chan int, chan<- int, []int, [10]int, map[int]struct{}, map[int]string, map[int]struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	}) (interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}, struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	})
	lifetimes   []int
	invocations []Complicated_MethodBInvocation
}

func (m *Complicated_MethodBMocker) Mock(nTimes int, f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Complicated_MethodBMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Complicated_MethodBMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Complicated_MethodBMocker) MockOnce(f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.Mock(1, f)
}

func (m *Complicated_MethodBMocker) MockForever(f func(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
})) {
	m.Mock(0, f)
}

func (m *Complicated_MethodBMocker) MockOutputs(nTimes int, out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.Mock(nTimes, func(chan int, <-chan int, chan<- int, []int, [10]int, map[int]struct{}, map[int]string, map[int]struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	}) (interface {
		Param1Method1(arg1 ...int) (out1 int, out2 error)
		Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
	}, struct {
		A int
		B int
		C int
		D func() (out1 interface {
			A() (out1 error)
		})
		E func() (out1 interface {
			A() (out1 error)
		})
		F func() (out1 interface {
			A() (out1 error)
		})
	}) {
		return out1, out2
	})
}

func (m *Complicated_MethodBMocker) MockOutputsOnce(out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.MockOutputs(1, out1, out2)
}

func (m *Complicated_MethodBMocker) MockOutputsForever(out1 interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, out2 struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.MockOutputs(0, out1, out2)
}

func (m *Complicated_MethodBMocker) MockDefaults(nTimes int) {
	var out1 interface {
		Param1Method1(...int) (int, error)
		Param1Method2(func(int, int, ...int) error) (int, error)
	}
	var out2 struct {
		A int
		B int
		C int
		D func() interface {
			A() error
		}
		E func() interface {
			A() error
		}
		F func() interface {
			A() error
		}
	}
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Complicated_MethodBMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Complicated_MethodBMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Complicated_MethodBMocker) Call(arg1 chan int, arg2 <-chan int, arg3 chan<- int, arg4 []int, arg5 [10]int, arg6 map[int]struct{}, arg7 map[int]string, arg8 map[int]struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) (interface {
	Param1Method1(arg1 ...int) (out1 int, out2 error)
	Param1Method2(arg1 func(arg1 int, arg2 int, arg3 ...int) (out1 error)) (out1 int, out2 error)
}, struct {
	A int
	B int
	C int
	D func() (out1 interface {
		A() (out1 error)
	})
	E func() (out1 interface {
		A() (out1 error)
	})
	F func() (out1 interface {
		A() (out1 error)
	})
}) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Complicated_MethodBMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	input := struct {
		Arg1 chan int
		Arg2 <-chan int
		Arg3 chan<- int
		Arg4 []int
		Arg5 [10]int
		Arg6 map[int]struct{}
		Arg7 map[int]string
		Arg8 map[int]struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}
	output := struct {
		Out1 interface {
			Param1Method1(...int) (int, error)
			Param1Method2(func(int, int, ...int) error) (int, error)
		}
		Out2 struct {
			A int
			B int
			C int
			D func() interface {
				A() error
			}
			E func() interface {
				A() error
			}
			F func() interface {
				A() error
			}
		}
	}{out1, out2}
	invoc := Complicated_MethodBInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Complicated_MethodBMocker) Invocations() []Complicated_MethodBInvocation {
	return m.invocations
}

func (m *Complicated_MethodBMocker) TakeOneInvocation() Complicated_MethodBInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Complicated_MethodBMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type MathMocker struct {
	Add      *Math_AddMocker
	Subtract *Math_SubtractMocker
}

type MockedMath struct {
	mocker *MathMocker
}

func (m *MockedMath) Add(ctx context.Context, a int, b int) (sum int, err error) {
	return m.mocker.Add.Call(ctx, a, b)
}
func (m *MockedMath) Subtract(ctx context.Context, a int, b int) (result int, err error) {
	return m.mocker.Subtract.Call(ctx, a, b)
}

func NewMockedMath() (*MockedMath, *MathMocker) {
	m := &MathMocker{Add: &Math_AddMocker{}, Subtract: &Math_SubtractMocker{}}
	return &MockedMath{m}, m
}

type Math_AddInvocation struct {
	Inputs struct {
		Ctx context.Context
		A   int
		B   int
	}
	Outputs struct {
		Sum int
		Err error
	}
}

type Math_AddMocker struct {
	mux         sync.Mutex
	handlers    []func(context.Context, int, int) (int, error)
	lifetimes   []int
	invocations []Math_AddInvocation
}

func (m *Math_AddMocker) Mock(nTimes int, f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Math_AddMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Math_AddMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Math_AddMocker) MockOnce(f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.Mock(1, f)
}

func (m *Math_AddMocker) MockForever(f func(ctx context.Context, a int, b int) (sum int, err error)) {
	m.Mock(0, f)
}

func (m *Math_AddMocker) MockOutputs(nTimes int, sum int, err error) {
	m.Mock(nTimes, func(context.Context, int, int) (int, error) {
		return sum, err
	})
}

func (m *Math_AddMocker) MockOutputsOnce(sum int, err error) {
	m.MockOutputs(1, sum, err)
}

func (m *Math_AddMocker) MockOutputsForever(sum int, err error) {
	m.MockOutputs(0, sum, err)
}

func (m *Math_AddMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Math_AddMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Math_AddMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Math_AddMocker) Call(ctx context.Context, a int, b int) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Math_AddMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(ctx, a, b)
	input := struct {
		Ctx context.Context
		A   int
		B   int
	}{ctx, a, b}
	output := struct {
		Sum int
		Err error
	}{out1, out2}
	invoc := Math_AddInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Math_AddMocker) Invocations() []Math_AddInvocation {
	return m.invocations
}

func (m *Math_AddMocker) TakeOneInvocation() Math_AddInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Math_AddMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type Math_SubtractInvocation struct {
	Inputs struct {
		Ctx context.Context
		A   int
		B   int
	}
	Outputs struct {
		Result int
		Err    error
	}
}

type Math_SubtractMocker struct {
	mux         sync.Mutex
	handlers    []func(context.Context, int, int) (int, error)
	lifetimes   []int
	invocations []Math_SubtractInvocation
}

func (m *Math_SubtractMocker) Mock(nTimes int, f func(ctx context.Context, a int, b int) (result int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Math_SubtractMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Math_SubtractMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Math_SubtractMocker) MockOnce(f func(ctx context.Context, a int, b int) (result int, err error)) {
	m.Mock(1, f)
}

func (m *Math_SubtractMocker) MockForever(f func(ctx context.Context, a int, b int) (result int, err error)) {
	m.Mock(0, f)
}

func (m *Math_SubtractMocker) MockOutputs(nTimes int, result int, err error) {
	m.Mock(nTimes, func(context.Context, int, int) (int, error) {
		return result, err
	})
}

func (m *Math_SubtractMocker) MockOutputsOnce(result int, err error) {
	m.MockOutputs(1, result, err)
}

func (m *Math_SubtractMocker) MockOutputsForever(result int, err error) {
	m.MockOutputs(0, result, err)
}

func (m *Math_SubtractMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Math_SubtractMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Math_SubtractMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Math_SubtractMocker) Call(ctx context.Context, a int, b int) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Math_SubtractMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(ctx, a, b)
	input := struct {
		Ctx context.Context
		A   int
		B   int
	}{ctx, a, b}
	output := struct {
		Result int
		Err    error
	}{out1, out2}
	invoc := Math_SubtractInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Math_SubtractMocker) Invocations() []Math_SubtractInvocation {
	return m.invocations
}

func (m *Math_SubtractMocker) TakeOneInvocation() Math_SubtractInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Math_SubtractMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type DoSomethingWithSomeDummyStructInvocation struct {
	Inputs struct {
		Dummy SomeDummyStruct
	}
	Outputs struct{}
}

type DoSomethingWithSomeDummyStructMocker struct {
	mux         sync.Mutex
	handlers    []func(SomeDummyStruct)
	lifetimes   []int
	invocations []DoSomethingWithSomeDummyStructInvocation
}

func (m *DoSomethingWithSomeDummyStructMocker) Mock(nTimes int, f func(dummy SomeDummyStruct)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("DoSomethingWithSomeDummyStructMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("DoSomethingWithSomeDummyStructMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockOnce(f func(dummy SomeDummyStruct)) {
	m.Mock(1, f)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockForever(f func(dummy SomeDummyStruct)) {
	m.Mock(0, f)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockOutputs(nTimes int) {
	m.Mock(nTimes, func(SomeDummyStruct) {
		return
	})
}

func (m *DoSomethingWithSomeDummyStructMocker) MockOutputsOnce() {
	m.MockOutputs(1)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockOutputsForever() {
	m.MockOutputs(0)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockDefaults(nTimes int) {
	m.MockOutputs(nTimes)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *DoSomethingWithSomeDummyStructMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *DoSomethingWithSomeDummyStructMocker) Call(dummy SomeDummyStruct) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("DoSomethingWithSomeDummyStructMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	handler(dummy)
	input := struct {
		Dummy SomeDummyStruct
	}{dummy}
	output := struct{}{}
	invoc := DoSomethingWithSomeDummyStructInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return
}

func (m *DoSomethingWithSomeDummyStructMocker) Invocations() []DoSomethingWithSomeDummyStructInvocation {
	return m.invocations
}

func (m *DoSomethingWithSomeDummyStructMocker) TakeOneInvocation() DoSomethingWithSomeDummyStructInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("DoSomethingWithSomeDummyStructMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

func NewMockedDoSomethingWithSomeDummyStruct() (func(SomeDummyStruct), *DoSomethingWithSomeDummyStructMocker) {
	m := &DoSomethingWithSomeDummyStructMocker{}
	return m.Call, m
}

type InterfaceCMocker struct {
	A      *InterfaceC_AMocker
	B      *InterfaceC_BMocker
	String *InterfaceC_StringMocker
	Read   *InterfaceC_ReadMocker
	Write  *InterfaceC_WriteMocker
	Close  *InterfaceC_CloseMocker
	C      *InterfaceC_CMocker
}

type MockedInterfaceC struct {
	mocker *InterfaceCMocker
}

func (m *MockedInterfaceC) A() {
	m.mocker.A.Call()
}
func (m *MockedInterfaceC) B() {
	m.mocker.B.Call()
}
func (m *MockedInterfaceC) String() (out1 string) {
	return m.mocker.String.Call()
}
func (m *MockedInterfaceC) Read(p []byte) (n int, err error) {
	return m.mocker.Read.Call(p)
}
func (m *MockedInterfaceC) Write(p []byte) (n int, err error) {
	return m.mocker.Write.Call(p)
}
func (m *MockedInterfaceC) Close() (out1 error) {
	return m.mocker.Close.Call()
}
func (m *MockedInterfaceC) C() {
	m.mocker.C.Call()
}

func NewMockedInterfaceC() (*MockedInterfaceC, *InterfaceCMocker) {
	m := &InterfaceCMocker{A: &InterfaceC_AMocker{}, B: &InterfaceC_BMocker{}, String: &InterfaceC_StringMocker{}, Read: &InterfaceC_ReadMocker{}, Write: &InterfaceC_WriteMocker{}, Close: &InterfaceC_CloseMocker{}, C: &InterfaceC_CMocker{}}
	return &MockedInterfaceC{m}, m
}

type InterfaceC_AInvocation struct {
	Inputs  struct{}
	Outputs struct{}
}

type InterfaceC_AMocker struct {
	mux         sync.Mutex
	handlers    []func()
	lifetimes   []int
	invocations []InterfaceC_AInvocation
}

func (m *InterfaceC_AMocker) Mock(nTimes int, f func()) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_AMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_AMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_AMocker) MockOnce(f func()) {
	m.Mock(1, f)
}

func (m *InterfaceC_AMocker) MockForever(f func()) {
	m.Mock(0, f)
}

func (m *InterfaceC_AMocker) MockOutputs(nTimes int) {
	m.Mock(nTimes, func() {
		return
	})
}

func (m *InterfaceC_AMocker) MockOutputsOnce() {
	m.MockOutputs(1)
}

func (m *InterfaceC_AMocker) MockOutputsForever() {
	m.MockOutputs(0)
}

func (m *InterfaceC_AMocker) MockDefaults(nTimes int) {
	m.MockOutputs(nTimes)
}

func (m *InterfaceC_AMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_AMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_AMocker) Call() {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_AMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	handler()
	input := struct{}{}
	output := struct{}{}
	invoc := InterfaceC_AInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return
}

func (m *InterfaceC_AMocker) Invocations() []InterfaceC_AInvocation {
	return m.invocations
}

func (m *InterfaceC_AMocker) TakeOneInvocation() InterfaceC_AInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_AMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_BInvocation struct {
	Inputs  struct{}
	Outputs struct{}
}

type InterfaceC_BMocker struct {
	mux         sync.Mutex
	handlers    []func()
	lifetimes   []int
	invocations []InterfaceC_BInvocation
}

func (m *InterfaceC_BMocker) Mock(nTimes int, f func()) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_BMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_BMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_BMocker) MockOnce(f func()) {
	m.Mock(1, f)
}

func (m *InterfaceC_BMocker) MockForever(f func()) {
	m.Mock(0, f)
}

func (m *InterfaceC_BMocker) MockOutputs(nTimes int) {
	m.Mock(nTimes, func() {
		return
	})
}

func (m *InterfaceC_BMocker) MockOutputsOnce() {
	m.MockOutputs(1)
}

func (m *InterfaceC_BMocker) MockOutputsForever() {
	m.MockOutputs(0)
}

func (m *InterfaceC_BMocker) MockDefaults(nTimes int) {
	m.MockOutputs(nTimes)
}

func (m *InterfaceC_BMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_BMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_BMocker) Call() {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_BMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	handler()
	input := struct{}{}
	output := struct{}{}
	invoc := InterfaceC_BInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return
}

func (m *InterfaceC_BMocker) Invocations() []InterfaceC_BInvocation {
	return m.invocations
}

func (m *InterfaceC_BMocker) TakeOneInvocation() InterfaceC_BInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_BMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_StringInvocation struct {
	Inputs  struct{}
	Outputs struct {
		Out1 string
	}
}

type InterfaceC_StringMocker struct {
	mux         sync.Mutex
	handlers    []func() string
	lifetimes   []int
	invocations []InterfaceC_StringInvocation
}

func (m *InterfaceC_StringMocker) Mock(nTimes int, f func() (out1 string)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_StringMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_StringMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_StringMocker) MockOnce(f func() (out1 string)) {
	m.Mock(1, f)
}

func (m *InterfaceC_StringMocker) MockForever(f func() (out1 string)) {
	m.Mock(0, f)
}

func (m *InterfaceC_StringMocker) MockOutputs(nTimes int, out1 string) {
	m.Mock(nTimes, func() string {
		return out1
	})
}

func (m *InterfaceC_StringMocker) MockOutputsOnce(out1 string) {
	m.MockOutputs(1, out1)
}

func (m *InterfaceC_StringMocker) MockOutputsForever(out1 string) {
	m.MockOutputs(0, out1)
}

func (m *InterfaceC_StringMocker) MockDefaults(nTimes int) {
	var out1 string
	m.MockOutputs(nTimes, out1)
}

func (m *InterfaceC_StringMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_StringMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_StringMocker) Call() string {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_StringMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1 := handler()
	input := struct{}{}
	output := struct {
		Out1 string
	}{out1}
	invoc := InterfaceC_StringInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1
}

func (m *InterfaceC_StringMocker) Invocations() []InterfaceC_StringInvocation {
	return m.invocations
}

func (m *InterfaceC_StringMocker) TakeOneInvocation() InterfaceC_StringInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_StringMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_ReadInvocation struct {
	Inputs struct {
		P []byte
	}
	Outputs struct {
		N   int
		Err error
	}
}

type InterfaceC_ReadMocker struct {
	mux         sync.Mutex
	handlers    []func([]byte) (int, error)
	lifetimes   []int
	invocations []InterfaceC_ReadInvocation
}

func (m *InterfaceC_ReadMocker) Mock(nTimes int, f func(p []byte) (n int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_ReadMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_ReadMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_ReadMocker) MockOnce(f func(p []byte) (n int, err error)) {
	m.Mock(1, f)
}

func (m *InterfaceC_ReadMocker) MockForever(f func(p []byte) (n int, err error)) {
	m.Mock(0, f)
}

func (m *InterfaceC_ReadMocker) MockOutputs(nTimes int, n int, err error) {
	m.Mock(nTimes, func([]byte) (int, error) {
		return n, err
	})
}

func (m *InterfaceC_ReadMocker) MockOutputsOnce(n int, err error) {
	m.MockOutputs(1, n, err)
}

func (m *InterfaceC_ReadMocker) MockOutputsForever(n int, err error) {
	m.MockOutputs(0, n, err)
}

func (m *InterfaceC_ReadMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *InterfaceC_ReadMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_ReadMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_ReadMocker) Call(p []byte) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_ReadMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(p)
	input := struct {
		P []byte
	}{p}
	output := struct {
		N   int
		Err error
	}{out1, out2}
	invoc := InterfaceC_ReadInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *InterfaceC_ReadMocker) Invocations() []InterfaceC_ReadInvocation {
	return m.invocations
}

func (m *InterfaceC_ReadMocker) TakeOneInvocation() InterfaceC_ReadInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_ReadMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_WriteInvocation struct {
	Inputs struct {
		P []byte
	}
	Outputs struct {
		N   int
		Err error
	}
}

type InterfaceC_WriteMocker struct {
	mux         sync.Mutex
	handlers    []func([]byte) (int, error)
	lifetimes   []int
	invocations []InterfaceC_WriteInvocation
}

func (m *InterfaceC_WriteMocker) Mock(nTimes int, f func(p []byte) (n int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_WriteMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_WriteMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_WriteMocker) MockOnce(f func(p []byte) (n int, err error)) {
	m.Mock(1, f)
}

func (m *InterfaceC_WriteMocker) MockForever(f func(p []byte) (n int, err error)) {
	m.Mock(0, f)
}

func (m *InterfaceC_WriteMocker) MockOutputs(nTimes int, n int, err error) {
	m.Mock(nTimes, func([]byte) (int, error) {
		return n, err
	})
}

func (m *InterfaceC_WriteMocker) MockOutputsOnce(n int, err error) {
	m.MockOutputs(1, n, err)
}

func (m *InterfaceC_WriteMocker) MockOutputsForever(n int, err error) {
	m.MockOutputs(0, n, err)
}

func (m *InterfaceC_WriteMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *InterfaceC_WriteMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_WriteMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_WriteMocker) Call(p []byte) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_WriteMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(p)
	input := struct {
		P []byte
	}{p}
	output := struct {
		N   int
		Err error
	}{out1, out2}
	invoc := InterfaceC_WriteInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *InterfaceC_WriteMocker) Invocations() []InterfaceC_WriteInvocation {
	return m.invocations
}

func (m *InterfaceC_WriteMocker) TakeOneInvocation() InterfaceC_WriteInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_WriteMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_CloseInvocation struct {
	Inputs  struct{}
	Outputs struct {
		Out1 error
	}
}

type InterfaceC_CloseMocker struct {
	mux         sync.Mutex
	handlers    []func() error
	lifetimes   []int
	invocations []InterfaceC_CloseInvocation
}

func (m *InterfaceC_CloseMocker) Mock(nTimes int, f func() (out1 error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_CloseMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_CloseMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_CloseMocker) MockOnce(f func() (out1 error)) {
	m.Mock(1, f)
}

func (m *InterfaceC_CloseMocker) MockForever(f func() (out1 error)) {
	m.Mock(0, f)
}

func (m *InterfaceC_CloseMocker) MockOutputs(nTimes int, out1 error) {
	m.Mock(nTimes, func() error {
		return out1
	})
}

func (m *InterfaceC_CloseMocker) MockOutputsOnce(out1 error) {
	m.MockOutputs(1, out1)
}

func (m *InterfaceC_CloseMocker) MockOutputsForever(out1 error) {
	m.MockOutputs(0, out1)
}

func (m *InterfaceC_CloseMocker) MockDefaults(nTimes int) {
	var out1 error
	m.MockOutputs(nTimes, out1)
}

func (m *InterfaceC_CloseMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_CloseMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_CloseMocker) Call() error {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_CloseMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1 := handler()
	input := struct{}{}
	output := struct {
		Out1 error
	}{out1}
	invoc := InterfaceC_CloseInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1
}

func (m *InterfaceC_CloseMocker) Invocations() []InterfaceC_CloseInvocation {
	return m.invocations
}

func (m *InterfaceC_CloseMocker) TakeOneInvocation() InterfaceC_CloseInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_CloseMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type InterfaceC_CInvocation struct {
	Inputs  struct{}
	Outputs struct{}
}

type InterfaceC_CMocker struct {
	mux         sync.Mutex
	handlers    []func()
	lifetimes   []int
	invocations []InterfaceC_CInvocation
}

func (m *InterfaceC_CMocker) Mock(nTimes int, f func()) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("InterfaceC_CMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("InterfaceC_CMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *InterfaceC_CMocker) MockOnce(f func()) {
	m.Mock(1, f)
}

func (m *InterfaceC_CMocker) MockForever(f func()) {
	m.Mock(0, f)
}

func (m *InterfaceC_CMocker) MockOutputs(nTimes int) {
	m.Mock(nTimes, func() {
		return
	})
}

func (m *InterfaceC_CMocker) MockOutputsOnce() {
	m.MockOutputs(1)
}

func (m *InterfaceC_CMocker) MockOutputsForever() {
	m.MockOutputs(0)
}

func (m *InterfaceC_CMocker) MockDefaults(nTimes int) {
	m.MockOutputs(nTimes)
}

func (m *InterfaceC_CMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *InterfaceC_CMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *InterfaceC_CMocker) Call() {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("InterfaceC_CMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	handler()
	input := struct{}{}
	output := struct{}{}
	invoc := InterfaceC_CInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return
}

func (m *InterfaceC_CMocker) Invocations() []InterfaceC_CInvocation {
	return m.invocations
}

func (m *InterfaceC_CMocker) TakeOneInvocation() InterfaceC_CInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("InterfaceC_CMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type ReaderMocker struct {
	Read *Reader_ReadMocker
}

type MockedReader struct {
	mocker *ReaderMocker
}

func (m *MockedReader) Read(p []byte) (n int, err error) {
	return m.mocker.Read.Call(p)
}

func NewMockedReader() (*MockedReader, *ReaderMocker) {
	m := &ReaderMocker{Read: &Reader_ReadMocker{}}
	return &MockedReader{m}, m
}

type Reader_ReadInvocation struct {
	Inputs struct {
		P []byte
	}
	Outputs struct {
		N   int
		Err error
	}
}

type Reader_ReadMocker struct {
	mux         sync.Mutex
	handlers    []func([]byte) (int, error)
	lifetimes   []int
	invocations []Reader_ReadInvocation
}

func (m *Reader_ReadMocker) Mock(nTimes int, f func(p []byte) (n int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Reader_ReadMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Reader_ReadMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Reader_ReadMocker) MockOnce(f func(p []byte) (n int, err error)) {
	m.Mock(1, f)
}

func (m *Reader_ReadMocker) MockForever(f func(p []byte) (n int, err error)) {
	m.Mock(0, f)
}

func (m *Reader_ReadMocker) MockOutputs(nTimes int, n int, err error) {
	m.Mock(nTimes, func([]byte) (int, error) {
		return n, err
	})
}

func (m *Reader_ReadMocker) MockOutputsOnce(n int, err error) {
	m.MockOutputs(1, n, err)
}

func (m *Reader_ReadMocker) MockOutputsForever(n int, err error) {
	m.MockOutputs(0, n, err)
}

func (m *Reader_ReadMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Reader_ReadMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Reader_ReadMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Reader_ReadMocker) Call(p []byte) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Reader_ReadMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(p)
	input := struct {
		P []byte
	}{p}
	output := struct {
		N   int
		Err error
	}{out1, out2}
	invoc := Reader_ReadInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Reader_ReadMocker) Invocations() []Reader_ReadInvocation {
	return m.invocations
}

func (m *Reader_ReadMocker) TakeOneInvocation() Reader_ReadInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Reader_ReadMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}

type WriterMocker struct {
	Write *Writer_WriteMocker
}

type MockedWriter struct {
	mocker *WriterMocker
}

func (m *MockedWriter) Write(p []byte) (n int, err error) {
	return m.mocker.Write.Call(p)
}

func NewMockedWriter() (*MockedWriter, *WriterMocker) {
	m := &WriterMocker{Write: &Writer_WriteMocker{}}
	return &MockedWriter{m}, m
}

type Writer_WriteInvocation struct {
	Inputs struct {
		P []byte
	}
	Outputs struct {
		N   int
		Err error
	}
}

type Writer_WriteMocker struct {
	mux         sync.Mutex
	handlers    []func([]byte) (int, error)
	lifetimes   []int
	invocations []Writer_WriteInvocation
}

func (m *Writer_WriteMocker) Mock(nTimes int, f func(p []byte) (n int, err error)) {
	m.mux.Lock()
	defer m.mux.Unlock()
	nHandler := len(m.lifetimes)
	if nHandler > 0 && m.lifetimes[nHandler-1] == 0 {
		panic("Writer_WriteMocker: already mocked forever")
	}
	if nTimes < 0 {
		panic("Writer_WriteMocker: invalid lifetime, valid lifetime are positive number and 0 (0 means forever)")
	}
	m.handlers = append(m.handlers, f)
	m.lifetimes = append(m.lifetimes, nTimes)
}

func (m *Writer_WriteMocker) MockOnce(f func(p []byte) (n int, err error)) {
	m.Mock(1, f)
}

func (m *Writer_WriteMocker) MockForever(f func(p []byte) (n int, err error)) {
	m.Mock(0, f)
}

func (m *Writer_WriteMocker) MockOutputs(nTimes int, n int, err error) {
	m.Mock(nTimes, func([]byte) (int, error) {
		return n, err
	})
}

func (m *Writer_WriteMocker) MockOutputsOnce(n int, err error) {
	m.MockOutputs(1, n, err)
}

func (m *Writer_WriteMocker) MockOutputsForever(n int, err error) {
	m.MockOutputs(0, n, err)
}

func (m *Writer_WriteMocker) MockDefaults(nTimes int) {
	var out1 int
	var out2 error
	m.MockOutputs(nTimes, out1, out2)
}

func (m *Writer_WriteMocker) MockDefaultsOnce() {
	m.MockDefaults(1)
}

func (m *Writer_WriteMocker) MockDefaultsForever() {
	m.MockDefaults(0)
}

func (m *Writer_WriteMocker) Call(p []byte) (int, error) {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.handlers) == 0 {
		panic("Writer_WriteMocker: no handler")
	}
	handler := m.handlers[0]
	if m.lifetimes[0] == 1 {
		m.handlers = m.handlers[1:]
		m.lifetimes = m.lifetimes[1:]
	} else if m.lifetimes[0] > 1 {
		m.lifetimes[0]--
	}
	out1, out2 := handler(p)
	input := struct {
		P []byte
	}{p}
	output := struct {
		N   int
		Err error
	}{out1, out2}
	invoc := Writer_WriteInvocation{input, output}
	m.invocations = append(m.invocations, invoc)
	return out1, out2
}

func (m *Writer_WriteMocker) Invocations() []Writer_WriteInvocation {
	return m.invocations
}

func (m *Writer_WriteMocker) TakeOneInvocation() Writer_WriteInvocation {
	m.mux.Lock()
	defer m.mux.Unlock()
	if len(m.invocations) == 0 {
		panic("Writer_WriteMocker: no invocations")
	}
	invoc := m.invocations[0]
	m.invocations = m.invocations[1:]
	return invoc
}
