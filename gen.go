package gomocker

import (
	"errors"
	"fmt"
	"github.com/dave/jennifer/jen"
	"io"
	"os"
	"reflect"
)

type generatorConfig struct {
	typ         reflect.Type
	name        string
	packageName string
	w           io.Writer
}

type GenerateOption func(m *generatorConfig)

func WithPackageName(packageName string) GenerateOption {
	return func(m *generatorConfig) {
		m.packageName = packageName
	}
}

func WithName(name string) GenerateOption {
	return func(m *generatorConfig) {
		m.name = name
	}
}

func WithWriter(w io.Writer) GenerateOption {
	return func(m *generatorConfig) {
		m.w = w
	}
}

func generateConfig(typ reflect.Type, opts ...GenerateOption) *generatorConfig {
	opt := &generatorConfig{typ: typ, name: typ.Name(), packageName: "mock", w: os.Stdout}
	for _, o := range opts {
		o(opt)
	}
	return opt
}

func GenerateFunctionMocker(typ reflect.Type, opts ...GenerateOption) error {
	if typ.Kind() != reflect.Func {
		return errors.New("not_a_function")
	}

	opt := generateConfig(typ, opts...)
	m := &mockedFunctionGenerator{
		ftype:    opt.typ,
		funcName: opt.name,
	}

	code := jen.NewFile(opt.packageName)
	code.HeaderComment("This code was generated by gomocker.")
	code.Add(m.generate())
	return code.Render(opt.w)
}

type mockedFunctionGenerator struct {
	ftype    reflect.Type
	funcName string
}

func (m *mockedFunctionGenerator) generate() jen.Code {
	return jen.
		Add(m.generateMockerStruct()).Line().
		Add(m.generateParamStruct()).Line().
		Add(m.generateReturnStruct()).Line().
		Add(m.generateInvocationStruct()).Line().
		Add(m.generateConstructor()).Line().
		Add(m.generateParseParams()).Line().
		Add(m.generateParseReturns()).Line().
		Add(m.generateMockCall()).Line().
		Add(m.generateMockReturnDefaultValue()).Line().
		Add(m.generateMockReturnDefaultValueForever()).Line().
		Add(m.generateMockReturnDefaultValueOnce()).Line().
		Add(m.generateMockReturnValues()).Line().
		Add(m.generateMockReturnValuesForever()).Line().
		Add(m.generateMockReturnValuesOnce()).Line().
		Add(m.generateMock()).Line().
		Add(m.generateMockForever()).Line().
		Add(m.generateMockOnce()).Line().
		Add(m.generateConvertInvocation()).Line().
		Add(m.generateInvocations()).Line().
		Add(m.generateTakeOneInvocation()).Line()
}

func (m *mockedFunctionGenerator) generateMockerStruct() jen.Code {
	return jen.Type().Id(m.mockerStructName()).Struct(jen.Id("mocker").Op("*").Qual(m.gomockerPackage(), "Mocker"))
}

func (m *mockedFunctionGenerator) mockerStructName() string {
	return m.functionName() + "Mocker"
}

func (m *mockedFunctionGenerator) functionName() string {
	return m.funcName
}

func (m *mockedFunctionGenerator) gomockerPackage() string {
	return "github.com/jauhararifin/gomocker"
}

func (m *mockedFunctionGenerator) generateParamStruct() jen.Code {
	return jen.Type().Id(m.mockerParamStructName()).Struct(m.generateInputParamDefinitions()...)
}

func (m *mockedFunctionGenerator) mockerParamStructName() string {
	return m.functionName() + "MockerParam"
}

func (m *mockedFunctionGenerator) generateInputParamDefinitions() []jen.Code {
	params := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())
	for i := 0; i < m.ftype.NumIn(); i++ {
		name := fmt.Sprintf("arg%d", i+1)
		params[i] = jen.Id(name).Add(generateJenFromType(m.ftype.In(i)))
	}
	return params
}

func (m *mockedFunctionGenerator) generateReturnStruct() jen.Code {
	return jen.Type().Id(m.mockerReturnStructName()).Struct(m.generateOutputParamDefinitions()...)
}

func (m *mockedFunctionGenerator) mockerReturnStructName() string {
	return m.functionName() + "MockerReturn"
}

func (m *mockedFunctionGenerator) generateOutputParamDefinitions() []jen.Code {
	params := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("r%d", i+1)
		params[i] = jen.Id(name).Add(generateJenFromType(m.ftype.Out(i)))
	}
	return params
}

func (m *mockedFunctionGenerator) generateInvocationStruct() jen.Code {
	return jen.Type().Id(m.mockerInvocationStructName()).Struct(
		jen.Id(m.invocationParametersFieldName()).Id(m.mockerParamStructName()),
		jen.Id(m.invocationReturnsFieldName()).Id(m.mockerReturnStructName()),
	)
}

func (m *mockedFunctionGenerator) mockerInvocationStructName() string {
	return m.functionName() + "MockerInvocation"
}

func (m *mockedFunctionGenerator) invocationParametersFieldName() string {
	return "Parameters"
}

func (m *mockedFunctionGenerator) invocationReturnsFieldName() string {
	return "Returns"
}

func (m *mockedFunctionGenerator) generateConstructor() jen.Code {
	return jen.Func().Id(m.mockerConstructorName()).
		Params(jen.Id("t").Qual("testing", "TB")).
		Params(jen.Op("*").Id(m.mockerStructName()), jen.Id(m.functionName())).
		Block(
			jen.Id("f").Op(":=").Qual(m.gomockerPackage(), "NewMocker").Call(
				jen.Id("t"),
				jen.Lit(m.functionName()),
			),
			jen.Id("m").Op(":=").Op("&").Id(m.mockerStructName()).Values(
				jen.Id("mocker").Op(":").Id("f"),
			),
			jen.Return(
				jen.Id("m"),
				jen.Id("m").Dot(m.callFunctionName()),
			),
		)
}

func (m *mockedFunctionGenerator) mockerConstructorName() string {
	return "NewMocked" + m.functionName()
}

func (m *mockedFunctionGenerator) parseReturnsFunctionName() string {
	return "parseReturns"
}

func (m *mockedFunctionGenerator) generateInputValues() []jen.Code {
	params := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())
	for i := 0; i < m.ftype.NumIn(); i++ {
		name := fmt.Sprintf("arg%d", i+1)
		params[i] = jen.Id(name)
	}
	return params
}

func (m *mockedFunctionGenerator) generateConstructorOutputValue() []jen.Code {
	vals := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("r%d", i+1)
		vals[i] = jen.Id("rets").Dot(name)
	}
	return vals
}

func (m *mockedFunctionGenerator) generateParseParams() jen.Code {
	body := make([]jen.Code, 0, 0)
	body = append(body, jen.Id("p").Op(":=").Id(m.mockerParamStructName()).Block())
	body = append(body, m.generateParseParamsConversion()...)
	body = append(body, jen.Return(jen.Id("p")))

	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.parseParamsFunctionName()).
		Params(jen.Id("params").Op("...").Interface()).
		Params(jen.Id(m.mockerParamStructName())).Block(body...)
}

func (m *mockedFunctionGenerator) generateParseParamsConversion() []jen.Code {
	convs := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())

	for i := 0; i < m.ftype.NumIn(); i++ {
		ptype := m.ftype.In(i)
		pname := fmt.Sprintf("arg%d", i+1)

		if isTypeNullable(ptype) {
			convs[i] = jen.If(jen.Id("params").Index(jen.Lit(i)).Op("!=").Nil()).Block(
				jen.Id("p").Dot(pname).Op("=").Id("params").Index(jen.Lit(i)).Assert(generateJenFromType(ptype)),
			)
		} else {
			convs[i] = jen.Id("p").Dot(pname).Op("=").Id("params").Index(jen.Lit(i)).Assert(generateJenFromType(ptype))
		}
	}

	return convs
}

func (m *mockedFunctionGenerator) generateParseReturns() jen.Code {
	body := make([]jen.Code, 0, 0)
	body = append(body, jen.Id("r").Op(":=").Id(m.mockerReturnStructName()).Block())
	body = append(body, m.generateParseReturnConversions()...)
	body = append(body, jen.Return(jen.Id("r")))

	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id("parseReturns").
		Params(jen.Id("returns").Op("...").Interface()).
		Params(jen.Id(m.mockerReturnStructName())).Block(body...)
}

func (m *mockedFunctionGenerator) generateParseReturnConversions() []jen.Code {
	convs := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		rtype := m.ftype.Out(i)
		pname := fmt.Sprintf("r%d", i+1)
		if isTypeNullable(rtype) {
			convs[i] = jen.If(jen.Id("returns").Index(jen.Lit(i)).Op("!=").Nil()).Block(
				jen.Id("r").Dot(pname).Op("=").Id("returns").Index(jen.Lit(i)).Assert(generateJenFromType(rtype)),
			)
		} else {
			convs[i] = jen.Id("r").Dot(pname).Op("=").Id("returns").Index(jen.Lit(i)).Assert(generateJenFromType(rtype))
		}
	}
	return convs
}

func (m *mockedFunctionGenerator) parseParamsFunctionName() string {
	return "parseParams"
}

func (m *mockedFunctionGenerator) generateMockCall() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.callFunctionName()).
		Params(m.generateInputParamDefinitions()...).
		Params(m.generateOutputParamDefinitions()...).
		Block(
			jen.Id("rets").Op(":=").Id("m").Dot(m.parseReturnsFunctionName()).
				Call(jen.Id("m").Dot("mocker").Dot("Call").Call(m.generateInputValues()...).Op("...")),
			jen.Return(m.generateConstructorOutputValue()...),
		)
}

func (m *mockedFunctionGenerator) callFunctionName() string {
	return "Call"
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValue() jen.Code {
	body := make([]jen.Code, 0, 0)
	for i := 0; i < m.ftype.NumOut(); i++ {
		rname := fmt.Sprintf("r%d", i+1)
		body = append(body, jen.Var().Id(rname).Add(generateJenFromType(m.ftype.Out(i))))
	}

	body = append(
		body,
		jen.Id("m").Dot("mocker").Dot("Mock").Call(
			jen.Id("nTimes"),
			jen.Qual(m.gomockerPackage(), "NewFixedReturnsFuncHandler").Call(m.generateOutputValues()...),
		),
	)

	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValueFuncName()).
		Params(jen.Id("nTimes").Id("int")).Block(body...)
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValueFuncName() string {
	return "MockReturnDefaultValue"
}

func (m *mockedFunctionGenerator) generateOutputValues() []jen.Code {
	returns := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("r%d", i+1)
		returns[i] = jen.Id(name)
	}
	return returns
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValueForever() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValueForeverFuncName()).Params().
		Block(jen.Id("m").Dot(m.mockerReturnDefaultValueFuncName()).Call(
			jen.Qual(m.gomockerPackage(), "LifetimeForever"),
		))
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValueForeverFuncName() string {
	return "MockReturnDefaultValueForever"
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValueOnce() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValueOnceFuncName()).Params().
		Block(jen.Id("m").Dot(m.mockerReturnDefaultValueFuncName()).Call(jen.Lit(1)), )
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValueOnceFuncName() string {
	return "MockReturnDefaultValueOnce"
}

func (m *mockedFunctionGenerator) generateMockReturnValues() jen.Code {
	functionParams := make([]jen.Code, 0, 0)
	functionParams = append(functionParams, jen.Id("nTimes").Id("int"))
	functionParams = append(functionParams, m.generateOutputParamDefinitions()...)
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesFuncName()).
		Params(functionParams...).Block(
		jen.Id("m").Dot("mocker").Dot("Mock").Call(
			jen.Id("nTimes"),
			jen.Qual(m.gomockerPackage(), "NewFixedReturnsFuncHandler").Call(m.generateOutputValues()...),
		),
	)
}

func (m *mockedFunctionGenerator) mockReturnValuesFuncName() string {
	return "MockReturnValues"
}

func (m *mockedFunctionGenerator) generateMockReturnValuesForever() jen.Code {
	p := []jen.Code{jen.Qual(m.gomockerPackage(), "LifetimeForever")}
	p = append(p, m.generateOutputValues()...)
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesForeverFuncName()).
		Params(m.generateOutputParamDefinitions()...).Block(
		jen.Id("m").Dot(m.mockReturnValuesFuncName()).Call(p...),
	)
}

func (m *mockedFunctionGenerator) mockReturnValuesForeverFuncName() string {
	return "MockReturnValuesForever"
}

func (m *mockedFunctionGenerator) generateMockReturnValuesOnce() jen.Code {
	p := []jen.Code{jen.Lit(1)}
	p = append(p, m.generateOutputValues()...)
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesOnceFuncName()).
		Params(m.generateOutputParamDefinitions()...).Block(
		jen.Id("m").Dot(m.mockReturnValuesFuncName()).Call(p...),
	)
}

func (m *mockedFunctionGenerator) mockReturnValuesOnceFuncName() string {
	return "MockReturnValuesOnce"
}

func (m *mockedFunctionGenerator) generateMock() jen.Code {
	params := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())
	for i := 0; i < m.ftype.NumIn(); i++ {
		name := fmt.Sprintf("arg%d", i+1)
		params[i] = jen.Id("params").Dot(name)
	}

	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockFuncName()).
		Params(jen.Id("nTimes").Id("int"), jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot("mocker").Dot("Mock").Call(
			jen.Id("nTimes"),
			jen.Func().
				Params(jen.Id("parameters").Op("...").Interface()).
				Params(jen.Index().Interface()).Block(
				jen.Id("params").Op(":=").Id("m").Dot("parseParams").Call(jen.Id("parameters").Op("...")),
				jen.List(m.generateOutputValues()...).Op(":=").Id("f").Call(params...),
				jen.Return(jen.Index().Interface().Values(m.generateOutputValues()...),
				),
			),
		),
	)
}

func (m *mockedFunctionGenerator) mockFuncName() string {
	return "Mock"
}

func (m *mockedFunctionGenerator) generateMockForever() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockForeverFuncName()).
		Params(jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot(m.mockFuncName()).Call(
			jen.Qual(m.gomockerPackage(), "LifetimeForever"),
			jen.Id("f"),
		),
	)
}

func (m *mockedFunctionGenerator) mockForeverFuncName() string {
	return "MockForever"
}

func (m *mockedFunctionGenerator) generateMockOnce() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockOnceFuncName()).
		Params(jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot(m.mockFuncName()).Call(jen.Lit(1), jen.Id("f")),
	)
}

func (m *mockedFunctionGenerator) mockOnceFuncName() string {
	return "MockOnce"
}

func (m *mockedFunctionGenerator) generateConvertInvocation() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.convertInvocationFuncName()).
		Params(jen.Id("invocation").Qual(m.gomockerPackage(), "Invocation")).
		Params(jen.Id(m.mockerInvocationStructName())).
		Block(
			jen.Id("iv").Op(":=").Id(m.mockerInvocationStructName()).Values(),
			jen.Id("iv").Dot("Parameters").
				Op("=").
				Id("m").Dot(m.parseParamsFunctionName()).Call(jen.Id("invocation").Dot("Parameters").Op("...")),
			jen.Id("iv").Dot("Returns").
				Op("=").
				Id("m").Dot(m.parseReturnsFunctionName()).Call(jen.Id("invocation").Dot("Returns").Op("...")),
			jen.Return(jen.Id("iv")),
		)
}

func (m *mockedFunctionGenerator) convertInvocationFuncName() string {
	return "convertInvocation"
}

func (m *mockedFunctionGenerator) generateInvocations() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.invocationsFuncName()).
		Params().
		Params(jen.Index().Id(m.mockerInvocationStructName())).
		Block(
			jen.Id("invocs").Op(":=").Make(jen.Index().Id(m.mockerInvocationStructName()), jen.Lit(0), jen.Lit(0)),
			jen.For(
				jen.List(jen.Op("_"), jen.Id("generalInvoc")).
					Op(":=").
					Range().
					Id("m").Dot("mocker").Dot("Invocations").Call(),
			).Block(
				jen.Id("invocs").
					Op("=").
					Append(
						jen.Id("invocs"),
						jen.Id("m").Dot(m.convertInvocationFuncName()).Call(jen.Id("generalInvoc")),
					),
			),
			jen.Return(jen.Id("invocs")),
		)
}

func (m *mockedFunctionGenerator) invocationsFuncName() string {
	return "Invocations"
}

func (m *mockedFunctionGenerator) generateTakeOneInvocation() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.takeOneInvocationFuncName()).
		Params().
		Params(jen.Id(m.mockerInvocationStructName())).
		Block(
			jen.Return(
				jen.Id("m").
					Dot(m.convertInvocationFuncName()).
					Call(jen.Id("m").Dot("mocker").Dot("TakeOneInvocation").Call()),
			),
		)
}

func (m *mockedFunctionGenerator) takeOneInvocationFuncName() string {
	return "TakeOneInvocation"
}

func GenerateServiceMocker(serviceType reflect.Type, opts ...GenerateOption) error {
	if serviceType.Kind() != reflect.Interface {
		return errors.New("not_an_interface")
	}

	opt := generateConfig(serviceType, opts...)
	m := &mockedServiceGenerator{
		stype:       opt.typ,
		serviceName: opt.name,
	}

	code := jen.NewFile(opt.packageName)
	code.HeaderComment("This code was generated by gomocker")
	code.Add(m.generate())
	return code.Render(opt.w)
}

type mockedServiceGenerator struct {
	stype       reflect.Type
	serviceName string

	methodGenerators []*mockedFunctionGenerator
	methods          []reflect.Method
}

func (m *mockedServiceGenerator) generate() jen.Code {
	m.methodGenerators = make([]*mockedFunctionGenerator, 0, 0)
	m.methods = make([]reflect.Method, 0, 0)
	for i := 0; i < m.stype.NumMethod(); i++ {
		method := m.stype.Method(i)
		funcGen := &mockedFunctionGenerator{
			ftype:    method.Type,
			funcName: m.mockedMethodName(method),
		}
		m.methodGenerators = append(m.methodGenerators, funcGen)
		m.methods = append(m.methods, method)
	}

	codes := make([]jen.Code, 0, 0)
	for _, funcgen := range m.methodGenerators {
		codes = append(codes, jen.Type().
			Id(funcgen.funcName).
			Func().
			Params(funcgen.generateInputParamDefinitions()...).
			Params(funcgen.generateOutputParamDefinitions()...).
			Line())

		codes = append(codes, funcgen.generate())
	}

	res := jen.Add(codes...).
		Add(m.generateServiceMockerStruct()).Line().
		Add(m.generateServiceImplStruct()).Line().
		Add(m.generateServiceMockerConstructor()).Line()
	for _, c := range m.genreateServiceMockedMethodImpls() {
		res.Add(c).Line()
	}
	return res
}

func (m *mockedServiceGenerator) mockedMethodName(method reflect.Method) string {
	return m.serviceName + "_" + method.Name
}

func (m *mockedServiceGenerator) generateServiceMockerStruct() jen.Code {
	return jen.Type().Id(m.serviceMockerStructName()).Struct(m.generateServiceMockerStructParams()...)
}

func (m *mockedServiceGenerator) serviceMockerStructName() string {
	return m.serviceName + "Mocker"
}

func (m *mockedServiceGenerator) generateServiceMockerStructParams() []jen.Code {
	params := make([]jen.Code, 0, 0)
	for i, funcgen := range m.methodGenerators {
		params = append(params, jen.Id(m.methods[i].Name).Op("*").Id(funcgen.mockerStructName()))
	}
	return params
}

func (m *mockedServiceGenerator) generateServiceImplStruct() jen.Code {
	return jen.Type().
		Id(m.serviceImplStructName()).
		Struct(jen.Id("mocker").Op("*").Id(m.serviceMockerStructName()))
}

func (m *mockedServiceGenerator) serviceImplStructName() string {
	return m.serviceName + "Mocked"
}

func (m *mockedServiceGenerator) generateServiceMockerConstructor() jen.Code {
	return jen.Func().
		Id(m.serviceMockerConstructorFuncName()).
		Params(jen.Id("t").Qual("testing", "TB")).
		Params(jen.Op("*").Id(m.serviceMockerStructName()), jen.Id(m.serviceName)).
		Block(
			jen.Id("m").Op(":=").Op("&").Id(m.serviceMockerStructName()).Values(),
			jen.Id("i").Op(":=").Op("&").Id(m.serviceImplStructName()).Values(
				jen.Id("mocker").Op(":").Id("m"),
			),
			jen.Return(jen.Id("m"), jen.Id("i")),
		)
}

func (m *mockedServiceGenerator) serviceMockerConstructorFuncName() string {
	return "NewMocked" + m.serviceName
}

func (m *mockedServiceGenerator) genreateServiceMockedMethodImpls() []jen.Code {
	impls := make([]jen.Code, 0, 0)
	for i, funcgen := range m.methodGenerators {
		impls = append(
			impls,
			jen.Func().
				Params(jen.Id("m").Op("*").Id(m.serviceImplStructName())).
				Id(m.methods[i].Name).
				Params(funcgen.generateInputParamDefinitions()...).
				Params(funcgen.generateOutputParamDefinitions()...).
				Block(
					jen.Return().
						Id("m").
						Dot("mocker").
						Dot(m.methods[i].Name).
						Dot("Call").
						Call(funcgen.generateInputValues()...),
				),
		)
	}
	return impls
}

func GenerateMocker(typ reflect.Type, opts ...GenerateOption) error {
	switch typ.Kind() {
	case reflect.Interface:
		return GenerateServiceMocker(typ, opts...)
	case reflect.Func:
		return GenerateFunctionMocker(typ, opts...)
	default:
		return errors.New("not a function or interface")
	}
}
