package gomocker

import (
	"context"
	"fmt"
	"go/token"
	"go/types"
	"io"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

type generateMockerOption struct {
	outputPackagePath string
}

type GenerateMockerOption func(option *generateMockerOption)

func WithOutputPackagePath(outputPackagePath string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.outputPackagePath = outputPackagePath
	}
}

type mockerGenerator struct {
	funcMockerGenerator interface {
		GenerateFunctionMocker(
			name string,
			funcType *types.Signature,
			withConstructor bool,
		) jen.Code
	}
	interfaceMockerGenerator interface {
		GenerateInterfaceMocker(
			name string,
			interfaceType *types.Interface,
		) jen.Code
	}
}

func (m *mockerGenerator) GenerateMocker(
	specs []TypeSpec,
	w io.Writer,
	options ...GenerateMockerOption,
) error {
	option := m.initOption(options...)

	file := m.createCodeGenFile(option)
	types, err := m.generateTypesFromSpecs(specs...)
	if err != nil {
		return err
	}

	for i, typ := range types {
		file.Add(m.generateEntityMockerByName(option, typ, specs[i].Name)).Line().Line()
	}

	return file.Render(w)
}

func (m *mockerGenerator) initOption(options ...GenerateMockerOption) *generateMockerOption {
	option := &generateMockerOption{}
	for _, opt := range options {
		opt(option)
	}
	return option
}

func (m *mockerGenerator) createCodeGenFile(option *generateMockerOption) *jen.File {
	outputPackagePath := "mock"
	if option.outputPackagePath != "" {
		outputPackagePath = option.outputPackagePath
	}
	file := jen.NewFilePath(outputPackagePath)
	file.HeaderComment("Code generated by gomocker " + gomockerPath + ". DO NOT EDIT.")

	return file
}

func (m *mockerGenerator) generateTypesFromSpecs(specs ...TypeSpec) ([]types.Type, error) {
	fileSet := token.NewFileSet()
	config := &packages.Config{
		Mode:    packages.LoadSyntax,
		Context: context.Background(),
		Fset:    fileSet,
	}

	packageNameSet := make(map[string]struct{})
	for _, spec := range specs {
		packageNameSet[spec.PackagePath] = struct{}{}
	}
	packageNames := make([]string, 0, len(packageNameSet))
	for packageName := range packageNameSet {
		packageNames = append(packageNames, packageName)
	}

	pkgs, err := packages.Load(config, packageNames...)
	if err != nil {
		return nil, fmt.Errorf("cannot load packages: %w", err)
	}

	resultMap := make(map[TypeSpec]types.Type, len(specs))
	for _, spec := range specs {
		resultMap[spec] = nil
	}
	for _, pkg := range pkgs {
		for ident, obj := range pkg.TypesInfo.Defs {
			typeSpec := TypeSpec{
				PackagePath: pkg.Name,
				Name: ident.Name,
			}
			if _, ok := resultMap[typeSpec]; ok {
				resultMap[typeSpec] = obj.Type()
			}
		}
	}

	results := make([]types.Type, 0, len(specs))
	for _, spec := range specs {
		if typ, ok := resultMap[spec]; ok {
			results = append(results, typ)
		} else {
			return nil, fmt.Errorf("cannot find type %s:%s", spec.PackagePath, spec.Name)
		}
	}

	return results, nil
}

func (m *mockerGenerator) generateEntityMockerByName(
	option *generateMockerOption,
	typ types.Type,
	name string,
) jen.Code {
	if funcType, ok := typ.Underlying().(*types.Signature); ok {
		return m.funcMockerGenerator.GenerateFunctionMocker(name, funcType, true)
	}

	if interfaceType, ok := typ.Underlying().(*types.Interface); ok {
		return m.interfaceMockerGenerator.GenerateInterfaceMocker(name, interfaceType)
	}

	panic(fmt.Errorf("only supported interface and function"))
}

func (m *mockerGenerator) generateInterfaceMocker(
	interfaceName string,
	interfaceType *types.Interface,
	funcMockerNamer FuncMockerNamer,
	interfaceMockerNamer InterfaceMockerNamer,
) jen.Code {
	generator := &interfaceMockerGeneratorHelper{
		interfaceName:        interfaceName,
		interfaceType:        interfaceType,
		funcMockerNamer:      funcMockerNamer,
		interfaceMockerNamer: interfaceMockerNamer,
	}
	return generator.generate()
}
