package gomocker

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"

	"github.com/dave/jennifer/jen"
)

const gomockerPath = "github.com/jauhararifin/gomocker"

type generateMockerOption struct {
	funcMockerNamer      FuncMockerNamer
	interfaceMockerNamer InterfaceMockerNamer
	inputFileName        string
	outputPackagePath    string
}

type GenerateMockerOption func(option *generateMockerOption)

func WithFuncMockerNamer(namer FuncMockerNamer) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.funcMockerNamer = namer
	}
}

func WithInterfaceMockerNamer(namer InterfaceMockerNamer) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.interfaceMockerNamer = namer
	}
}

func WithInputFileName(inputFileName string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.inputFileName = inputFileName
	}
}

func WithOutputPackagePath(outputPackagePath string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.outputPackagePath = outputPackagePath
	}
}

func GenerateMocker(r io.Reader, names []string, w io.Writer, options ...GenerateMockerOption) error {
	option := initOption(options...)

	fileAst, err := parseSourceFile(option, r)
	if err != nil {
		return err
	}

	file := createCodeGenFile(option, fileAst)
	exprCodeGen := newExprCodeGenerator(fileAst)

	for _, name := range names {
		code, err := generateEntityMockerByName(option, fileAst, exprCodeGen, name)
		if err != nil {
			return err
		}
		file.Add(code).Line().Line()
	}

	return file.Render(w)
}

func initOption(options ...GenerateMockerOption) *generateMockerOption {
	option := &generateMockerOption{
		funcMockerNamer:      &defaultFuncMockerNamer{},
		interfaceMockerNamer: &defaultInterfaceMockerNamer{},
		inputFileName:        "dummyfile.go",
	}
	for _, opt := range options {
		opt(option)
	}
	return option
}

func parseSourceFile(option *generateMockerOption, r io.Reader) (*ast.File, error) {
	fset := token.NewFileSet()
	fileAst, err := parser.ParseFile(fset, option.inputFileName, r, 0)
	if err != nil {
		return nil, fmt.Errorf("cannot parse go code: %w", err)
	}
	return fileAst, nil
}

func createCodeGenFile(option *generateMockerOption, fileAst *ast.File) *jen.File {
	outputPackagePath := fileAst.Name.String()
	if len(option.outputPackagePath) > 0 {
		outputPackagePath = option.outputPackagePath
	}
	file := jen.NewFilePath(outputPackagePath)
	file.HeaderComment("Code generated by gomocker " + gomockerPath + ". DO NOT EDIT.")

	return file
}

func generateEntityMockerByName(
	option *generateMockerOption,
	fileAst *ast.File,
	exprCodeGen *exprCodeGenerator,
	name string,
) (jen.Code, error) {
	typ := getDeclarationByName(fileAst, name)
	if typ == nil {
		return nil, fmt.Errorf("cannot find function or interface %s", name)
	}

	if _, ok := typ.Type.(*ast.FuncType); ok {
		code, err := generateFunctionMocker(typ, option.funcMockerNamer, exprCodeGen)
		if err != nil {
			return nil, err
		}
		return code, nil
	}

	if _, ok := typ.Type.(*ast.InterfaceType); ok {
		code, err := generateInterfaceMocker(typ, option.funcMockerNamer, option.interfaceMockerNamer, exprCodeGen)
		if err != nil {
			return nil, err
		}
		return code, nil
	}

	return nil, fmt.Errorf("only supported interface and function")
}

func getDeclarationByName(f *ast.File, name string) *ast.TypeSpec {
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			if typeSpec.Name.String() != name {
				continue
			}

			_, IsInterface := typeSpec.Type.(*ast.InterfaceType)
			_, IsFunction := typeSpec.Type.(*ast.FuncType)
			if IsInterface || IsFunction {
				return typeSpec
			}
		}
	}
	return nil
}

func generateFunctionMocker(
	funcType *ast.TypeSpec,
	mockerNamer FuncMockerNamer,
	exprCodeGen *exprCodeGenerator,
) (jen.Code, error) {
	funcMockerGenerator := funcMockerGenerator{
		funcName:        funcType.Name.String(),
		funcType:        funcType.Type.(*ast.FuncType),
		mockerNamer:     mockerNamer,
		withConstructor: true,
		exprCodeGen:     exprCodeGen,
	}
	return funcMockerGenerator.generate()
}

func generateInterfaceMocker(
	interfaceType *ast.TypeSpec,
	funcMockerNamer FuncMockerNamer,
	interfaceMockerNamer InterfaceMockerNamer,
	exprCodeGen *exprCodeGenerator,
) (jen.Code, error) {
	generator := &interfaceMockerGenerator{
		interfaceName:        interfaceType.Name.String(),
		interfaceType:        interfaceType.Type.(*ast.InterfaceType),
		funcMockerNamer:      funcMockerNamer,
		interfaceMockerNamer: interfaceMockerNamer,
		exprCodeGen:          exprCodeGen,
	}
	return generator.generate()
}
