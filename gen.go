package gomocker

import (
	"fmt"
	"io"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/jauhararifin/gotype"
)

type generateMockerOption struct {
	outputPackagePath string
}

type GenerateMockerOption func(option *generateMockerOption)

func WithOutputPackagePath(outputPackagePath string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.outputPackagePath = outputPackagePath
	}
}

type mockerGenerator struct {
	funcMockerGenerator interface {
		GenerateFunctionMocker(
			name string,
			funcType gotype.FuncType,
			withConstructor bool,
		) jen.Code
	}
	interfaceMockerGenerator interface {
		GenerateInterfaceMocker(
			name string,
			interfaceType gotype.InterfaceType,
		) jen.Code
	}
}

func (m *mockerGenerator) GenerateMocker(
	specs []gotype.TypeSpec,
	w io.Writer,
	options ...GenerateMockerOption,
) error {
	option := m.initOption(options...)

	file := m.createCodeGenFile(option)
	types, err := gotype.GenerateTypesFromSpecs(specs...)
	if err != nil {
		return err
	}

	for i, typ := range types {
		file.Add(m.generateEntityMockerByName(option, typ, specs[i].Name)).Line().Line()
	}

	return file.Render(w)
}

func (m *mockerGenerator) initOption(options ...GenerateMockerOption) *generateMockerOption {
	option := &generateMockerOption{}
	for _, opt := range options {
		opt(option)
	}
	return option
}

func (m *mockerGenerator) createCodeGenFile(option *generateMockerOption) *jen.File {
	outputPackagePath := "mock"
	if option.outputPackagePath != "" {
		outputPackagePath = option.outputPackagePath
	}

	packageName := m.generatePackageName(outputPackagePath)

	file := jen.NewFilePathName(outputPackagePath, packageName)
	file.HeaderComment("Code generated by gomocker " + gomockerPath + ". DO NOT EDIT.")

	return file
}

func (m *mockerGenerator) generatePackageName(packagePath string) string {
	name := packagePath
	if strings.HasSuffix(name, "/") {
		name = name[:len(name)-1]
	}
	if strings.Contains(name, "/") {
		name = name[strings.LastIndex(name, "/")+1:]
	}
	return name
}

func (m *mockerGenerator) generateEntityMockerByName(
	option *generateMockerOption,
	typ gotype.Type,
	name string,
) jen.Code {
	if typ.FuncType != nil {
		return m.funcMockerGenerator.GenerateFunctionMocker(name, *typ.FuncType, true)
	}

	if typ.InterfaceType != nil {
		return m.interfaceMockerGenerator.GenerateInterfaceMocker(name, *typ.InterfaceType)
	}

	panic(fmt.Errorf("only supported interface and function"))
}

func (m *mockerGenerator) generateFunctionMocker(
	funcName string,
	funcType gotype.FuncType,
	mockerNamer FuncMockerNamer,
) jen.Code {
	funcMockerGenerator := funcMockerGeneratorHelper{
		funcName:        funcName,
		funcType:        funcType,
		mockerNamer:     mockerNamer,
		withConstructor: true,
	}
	return funcMockerGenerator.generate()
}

func (m *mockerGenerator) generateInterfaceMocker(
	interfaceName string,
	interfaceType gotype.InterfaceType,
	funcMockerNamer FuncMockerNamer,
	interfaceMockerNamer InterfaceMockerNamer,
) jen.Code {
	generator := &interfaceMockerGeneratorHelper{
		interfaceName:        interfaceName,
		interfaceType:        interfaceType,
		funcMockerNamer:      funcMockerNamer,
		interfaceMockerNamer: interfaceMockerNamer,
	}
	return generator.generate()
}
