package gomocker

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"

	"github.com/dave/jennifer/jen"
)

const gomockerPath = "github.com/jauhararifin/gomocker"

type generateMockerOption struct {
	namer             Namer
	inputFileName     string
	outputPackagePath string
}

type GenerateMockerOption func(option *generateMockerOption)

func WithNamer(namer Namer) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.namer = namer
	}
}

func WithInputFileName(inputFileName string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.inputFileName = inputFileName
	}
}

func WithOutputPackagePath(outputPackagePath string) GenerateMockerOption {
	return func(option *generateMockerOption) {
		option.outputPackagePath = outputPackagePath
	}
}

func GenerateMocker(r io.Reader, names []string, w io.Writer, options ...GenerateMockerOption) error {
	option := &generateMockerOption{
		namer: &defaultNamer{},
		inputFileName: "dummyfile.go",
	}
	for _, opt := range options {
		opt(option)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, option.inputFileName, r, 0)
	if err != nil {
		return fmt.Errorf("cannot parse go code: %w", err)
	}

	outputPackagePath := f.Name.String()
	if len(option.outputPackagePath) > 0 {
		outputPackagePath = option.outputPackagePath
	}
	file := jen.NewFilePath(outputPackagePath)
	file.HeaderComment("Code generated by gomocker " + gomockerPath + ". DO NOT EDIT.")

	for _, name := range names {
		typ := getDeclarationByName(f, name)
		if typ == nil {
			return fmt.Errorf("cannot find function or interface %s", name)
		}

		switch typ.Type.(type) {
		case *ast.FuncType:
			code, err := generateFunctionMocker(typ, option.namer)
			if err != nil {
				return err
			}
			file.Add(code).Line().Line()
		case *ast.InterfaceType:
			code, err := generateInterfaceMocker(typ, option.namer)
			if err != nil {
				return err
			}
			file.Add(code).Line().Line()
		default:
			return fmt.Errorf("only supported interface and function")
		}
	}

	return file.Render(w)
}

func generateFunctionMocker(funcType *ast.TypeSpec, mockerNamer Namer) (jen.Code, error) {
	funcMockerGenerator := funcMockerGenerator{
		spec:        funcType,
		mockerNamer: mockerNamer,
	}
	return funcMockerGenerator.generate()
}

func generateInterfaceMocker(interfaceType *ast.TypeSpec, mockerNamer Namer) (jen.Code, error) {
	//generator := &interfaceMockerGenerator{
	//	serviceType:          ,
	//	name:                 t.Name(),
	//	mockerName:           t.Name() + "Mocker",
	//	mockedName:           "Mocked" + t.Name(),
	//	funcMockerNamer:      &defaultFuncMockedNamer{},
	//	funcMockedGenerators: nil,
	//}
	//return generator.generate()
	return nil, fmt.Errorf("interface is not supported yet")
}
