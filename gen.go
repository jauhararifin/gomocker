package gomocker

import (
	"errors"
	"fmt"
	"github.com/dave/jennifer/jen"
	"io"
	"os"
	"reflect"
)

const generatedCodeHeader = "Code generated by gomocker. DO NOT EDIT."

type generatorConfig struct {
	typ         reflect.Type
	name        string
	packageName string
	w           io.Writer
}

type GenerateOption func(m *generatorConfig)

func WithPackageName(packageName string) GenerateOption {
	return func(m *generatorConfig) {
		m.packageName = packageName
	}
}

func WithName(name string) GenerateOption {
	return func(m *generatorConfig) {
		m.name = name
	}
}

func WithWriter(w io.Writer) GenerateOption {
	return func(m *generatorConfig) {
		m.w = w
	}
}

func generateConfig(typ reflect.Type, opts ...GenerateOption) *generatorConfig {
	opt := &generatorConfig{typ: typ, name: typ.Name(), packageName: "mock", w: os.Stdout}
	for _, o := range opts {
		o(opt)
	}
	return opt
}

func GenerateFunctionMocker(typ reflect.Type, opts ...GenerateOption) error {
	if typ.Kind() != reflect.Func {
		return errors.New("not a function")
	}

	opt := generateConfig(typ, opts...)
	m := &mockedFunctionGenerator{
		ftype:    opt.typ,
		funcName: opt.name,
	}

	code := jen.NewFile(opt.packageName)
	code.HeaderComment(generatedCodeHeader)
	code.Add(m.generate())
	return code.Render(opt.w)
}

type mockedFunctionGenerator struct {
	ftype    reflect.Type
	funcName string
}

func (m *mockedFunctionGenerator) generate() jen.Code {
	return jen.
		Add(m.generateMockerStruct()).Line().
		Add(m.generateParamStruct()).Line().
		Add(m.generateReturnStruct()).Line().
		Add(m.generateInvocationStruct()).Line().
		Add(m.generateConstructor()).Line().
		Add(m.generateMockCall()).Line().
		Add(m.generateMockReturnDefaultValues()).Line().
		Add(m.generateMockReturnDefaultValuesForever()).Line().
		Add(m.generateMockReturnDefaultValueOnce()).Line().
		Add(m.generateMockReturnValues()).Line().
		Add(m.generateMockReturnValuesForever()).Line().
		Add(m.generateMockReturnValuesOnce()).Line().
		Add(m.generateMock()).Line().
		Add(m.generateMockForever()).Line().
		Add(m.generateMockOnce()).Line().
		Add(m.generateInvocations()).Line().
		Add(m.generateTakeOneInvocation()).Line()
}

func (m *mockedFunctionGenerator) generateMockerStruct() jen.Code {
	return jen.Type().
		Id(m.mockerStructName()).
		Struct(
			jen.Id("mocker").Op("*").Qual(m.gomockerPackage(), "ReflectMocker"),
		)
}

func (m *mockedFunctionGenerator) mockerStructName() string {
	return m.functionName() + "Mocker"
}

func (m *mockedFunctionGenerator) functionName() string {
	return m.funcName
}

func (m *mockedFunctionGenerator) gomockerPackage() string {
	return "github.com/jauhararifin/gomocker"
}

func (m *mockedFunctionGenerator) generateParamStruct() jen.Code {
	return jen.Type().
		Id(m.mockerParamStructName()).
		Struct(m.generateInputParamDefinitions(false)...)
}

func (m *mockedFunctionGenerator) mockerParamStructName() string {
	return m.functionName() + "MockerParam"
}

func (m *mockedFunctionGenerator) generateInputParamDefinitions(variadic bool) []jen.Code {
	params := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())
	for i := 0; i < m.ftype.NumIn(); i++ {
		name := fmt.Sprintf("Arg%d", i+1)
		code := jen.Id(name)
		if variadic && i == m.ftype.NumIn()-1 {
			code.Op("...").Add(generateJenFromType(m.ftype.In(i).Elem()))
		} else {
			code.Add(generateJenFromType(m.ftype.In(i)))
		}
		params[i] = code
	}
	return params
}

func (m *mockedFunctionGenerator) generateReturnStruct() jen.Code {
	return jen.Type().
		Id(m.mockerReturnStructName()).
		Struct(m.generateOutputParamDefinitions()...)
}

func (m *mockedFunctionGenerator) mockerReturnStructName() string {
	return m.functionName() + "MockerReturn"
}

func (m *mockedFunctionGenerator) generateOutputParamDefinitions() []jen.Code {
	params := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("R%d", i+1)
		params[i] = jen.Id(name).Add(generateJenFromType(m.ftype.Out(i)))
	}
	return params
}

func (m *mockedFunctionGenerator) generateInvocationStruct() jen.Code {
	return jen.Type().Id(m.mockerInvocationStructName()).Struct(
		jen.Id(m.invocationParametersFieldName()).Id(m.mockerParamStructName()),
		jen.Id(m.invocationReturnsFieldName()).Id(m.mockerReturnStructName()),
	)
}

func (m *mockedFunctionGenerator) mockerInvocationStructName() string {
	return m.functionName() + "MockerInvocation"
}

func (m *mockedFunctionGenerator) invocationParametersFieldName() string {
	return "Parameters"
}

func (m *mockedFunctionGenerator) invocationReturnsFieldName() string {
	return "Returns"
}

func (m *mockedFunctionGenerator) generateConstructor() jen.Code {
	return jen.Func().Id(m.mockerConstructorName()).
		Params(jen.Id("t").Qual("testing", "TB")).
		Params(jen.Op("*").Id(m.mockerStructName()), jen.Id(m.functionName())).
		Block(
			jen.Id("f").Op(":=").Qual(m.gomockerPackage(), "NewReflectMocker").Call(
				jen.Id("t"),
				jen.Lit(m.functionName()),
				jen.Lit(m.ftype.IsVariadic()),
				jen.Id(m.mockerInvocationStructName()).Values(),
			),
			jen.Id("m").Op(":=").Op("&").Id(m.mockerStructName()).Values(
				jen.Id("mocker").Op(":").Id("f"),
			),
			jen.Return(
				jen.Id("m"),
				jen.Id("m").Dot(m.callFunctionName()),
			),
		)
}

func (m *mockedFunctionGenerator) mockerConstructorName() string {
	return "NewMocked" + m.functionName()
}

func (m *mockedFunctionGenerator) generateMockCall() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.callFunctionName()).
		Params(m.generateInputParamDefinitions(m.ftype.IsVariadic())...).
		Params(m.generateOutputParamDefinitions()...).
		Block(
			jen.Id("rets").
				Op(":=").
				Id("m").Dot("mocker").Dot(m.mockerCallFunctionName()).
				Call(m.generateInputValues(true)...).
				Assert(jen.Id(m.mockerReturnStructName())),
			jen.Return(m.generateOutputValues()...),
		)
}

func (m *mockedFunctionGenerator) callFunctionName() string {
	return "Call"
}

func (m *mockedFunctionGenerator) mockerCallFunctionName() string {
	if m.ftype.IsVariadic() {
		return "CallVariadic"
	}
	return "Call"
}

func (m *mockedFunctionGenerator) generateInputValues(ignoreVariadic bool) []jen.Code {
	params := make([]jen.Code, m.ftype.NumIn(), m.ftype.NumIn())
	for i := 0; i < m.ftype.NumIn(); i++ {
		name := fmt.Sprintf("Arg%d", i+1)
		code := jen.Id(name)
		if !ignoreVariadic && m.ftype.IsVariadic() && i == m.ftype.NumIn() - 1 {
			code.Op("...")
		}
		params[i] = code
	}
	return params
}

func (m *mockedFunctionGenerator) generateOutputValues() []jen.Code {
	vals := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("R%d", i+1)
		vals[i] = jen.Id("rets").Dot(name)
	}
	return vals
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValues() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValuesFuncName()).
		Params(jen.Id("nTimes").Id("int")).
		Block(jen.Id("m").Dot("mocker").Dot("MockReturnDefaultValues").Call(jen.Id("nTimes")))
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValuesFuncName() string {
	return "MockReturnDefaultValues"
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValuesForever() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValuesForeverFuncName()).Params().
		Block(jen.Id("m").Dot("mocker").Dot("MockReturnDefaultValuesForever").Call())
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValuesForeverFuncName() string {
	return "MockReturnDefaultValuesForever"
}

func (m *mockedFunctionGenerator) generateMockReturnDefaultValueOnce() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockerReturnDefaultValuesOnceFuncName()).Params().
		Block(jen.Id("m").Dot("mocker").Dot("MockReturnDefaultValuesOnce").Call())
}

func (m *mockedFunctionGenerator) mockerReturnDefaultValuesOnceFuncName() string {
	return "MockReturnDefaultValuesOnce"
}

func (m *mockedFunctionGenerator) generateMockReturnValues() jen.Code {
	functionParams := make([]jen.Code, 0, 0)
	functionParams = append(functionParams, jen.Id("nTimes").Id("int"))
	functionParams = append(functionParams, m.generateOutputParamDefinitions()...)
	mockerParams := []jen.Code{jen.Id("nTimes")}
	mockerParams = append(mockerParams, m.generateOutputValuesForParam()...)
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesFuncName()).
		Params(functionParams...).Block(
		jen.Id("m").Dot("mocker").Dot("MockReturnValues").Call(mockerParams...),
	)
}

func (m *mockedFunctionGenerator) generateOutputValuesForParam() []jen.Code {
	vals := make([]jen.Code, m.ftype.NumOut(), m.ftype.NumOut())
	for i := 0; i < m.ftype.NumOut(); i++ {
		name := fmt.Sprintf("R%d", i+1)
		vals[i] = jen.Id(name)
	}
	return vals
}

func (m *mockedFunctionGenerator) mockReturnValuesFuncName() string {
	return "MockReturnValues"
}

func (m *mockedFunctionGenerator) generateMockReturnValuesForever() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesForeverFuncName()).
		Params(m.generateOutputParamDefinitions()...).Block(
		jen.Id("m").Dot("mocker").Dot("MockReturnValuesForever").Call(m.generateOutputValuesForParam()...),
	)
}

func (m *mockedFunctionGenerator) mockReturnValuesForeverFuncName() string {
	return "MockReturnValuesForever"
}

func (m *mockedFunctionGenerator) generateMockReturnValuesOnce() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockReturnValuesOnceFuncName()).
		Params(m.generateOutputParamDefinitions()...).Block(
		jen.Id("m").Dot("mocker").Dot("MockReturnValuesOnce").Call(m.generateOutputValuesForParam()...),
	)
}

func (m *mockedFunctionGenerator) mockReturnValuesOnceFuncName() string {
	return "MockReturnValuesOnce"
}

func (m *mockedFunctionGenerator) generateMock() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockFuncName()).
		Params(jen.Id("nTimes").Id("int"), jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot("mocker").Dot("Mock").Call(jen.Id("nTimes"), jen.Id("f")),
	)
}

func (m *mockedFunctionGenerator) mockFuncName() string {
	return "Mock"
}

func (m *mockedFunctionGenerator) generateMockForever() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockForeverFuncName()).
		Params(jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot("mocker").Dot("MockForever").Call(jen.Id("f")),
	)
}

func (m *mockedFunctionGenerator) mockForeverFuncName() string {
	return "MockForever"
}

func (m *mockedFunctionGenerator) generateMockOnce() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.mockOnceFuncName()).
		Params(jen.Id("f").Add(generateJenFromType(m.ftype))).Block(
		jen.Id("m").Dot("mocker").Dot("MockOnce").Call(jen.Id("f")),
	)
}

func (m *mockedFunctionGenerator) mockOnceFuncName() string {
	return "MockOnce"
}

func (m *mockedFunctionGenerator) generateInvocations() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.invocationsFuncName()).
		Params().
		Params(jen.Index().Id(m.mockerInvocationStructName())).
		Block(
			jen.Id("invocs").Op(":=").Id("m").Dot("mocker").Dot("Invocations").Call(),
			jen.Id("results").Op(":=").Make(
				jen.Index().Id(m.mockerInvocationStructName()),
				jen.Len(jen.Id("invocs")),
				jen.Len(jen.Id("invocs")),
			),
			jen.For(jen.List(jen.Id("i"), jen.Id("iv")).Op(":=").Range().Id("invocs")).
				Block(
					jen.Id("results").Index(jen.Id("i")).Op("=").Id("iv").Assert(jen.Id(m.mockerInvocationStructName())),
				),
			jen.Return(jen.Id("results")),
		)
}

func (m *mockedFunctionGenerator) invocationsFuncName() string {
	return "Invocations"
}

func (m *mockedFunctionGenerator) generateTakeOneInvocation() jen.Code {
	return jen.Func().
		Params(jen.Id("m").Op("*").Id(m.mockerStructName())).
		Id(m.takeOneInvocationFuncName()).
		Params().
		Params(jen.Id(m.mockerInvocationStructName())).
		Block(
			jen.Return(
				jen.Id("m").
					Dot("mocker").
					Dot("TakeOneInvocation").
					Call().Assert(jen.Id(m.mockerInvocationStructName())),
			),
		)
}

func (m *mockedFunctionGenerator) takeOneInvocationFuncName() string {
	return "TakeOneInvocation"
}

func GenerateServiceMocker(serviceType reflect.Type, opts ...GenerateOption) error {
	if serviceType.Kind() != reflect.Interface {
		return errors.New("not_an_interface")
	}

	opt := generateConfig(serviceType, opts...)
	m := &mockedServiceGenerator{
		stype:       opt.typ,
		serviceName: opt.name,
	}

	code := jen.NewFile(opt.packageName)
	code.HeaderComment(generatedCodeHeader)
	code.Add(m.generate())
	return code.Render(opt.w)
}

type mockedServiceGenerator struct {
	stype       reflect.Type
	serviceName string

	methodGenerators []*mockedFunctionGenerator
	methods          []reflect.Method
}

func (m *mockedServiceGenerator) generate() jen.Code {
	m.methodGenerators = make([]*mockedFunctionGenerator, 0, 0)
	m.methods = make([]reflect.Method, 0, 0)
	for i := 0; i < m.stype.NumMethod(); i++ {
		method := m.stype.Method(i)
		funcGen := &mockedFunctionGenerator{
			ftype:    method.Type,
			funcName: m.mockedMethodName(method),
		}
		m.methodGenerators = append(m.methodGenerators, funcGen)
		m.methods = append(m.methods, method)
	}

	codes := make([]jen.Code, 0, 0)
	for _, funcgen := range m.methodGenerators {
		codes = append(codes, jen.Type().
			Id(funcgen.funcName).
			Func().
			Params(funcgen.generateInputParamDefinitions(funcgen.ftype.IsVariadic())...).
			Params(funcgen.generateOutputParamDefinitions()...).
			Line())

		codes = append(codes, funcgen.generate())
	}

	res := jen.Add(codes...).
		Add(m.generateServiceMockerStruct()).Line().
		Add(m.generateServiceImplStruct()).Line().
		Add(m.generateServiceMockerConstructor()).Line()
	for _, c := range m.genreateServiceMockedMethodImpls() {
		res.Add(c).Line()
	}
	return res
}

func (m *mockedServiceGenerator) mockedMethodName(method reflect.Method) string {
	return m.serviceName + "_" + method.Name
}

func (m *mockedServiceGenerator) generateServiceMockerStruct() jen.Code {
	return jen.Type().Id(m.serviceMockerStructName()).Struct(m.generateServiceMockerStructParams()...)
}

func (m *mockedServiceGenerator) serviceMockerStructName() string {
	return m.serviceName + "Mocker"
}

func (m *mockedServiceGenerator) generateServiceMockerStructParams() []jen.Code {
	params := make([]jen.Code, 0, 0)
	for i, funcgen := range m.methodGenerators {
		params = append(params, jen.Id(m.methods[i].Name).Op("*").Id(funcgen.mockerStructName()))
	}
	return params
}

func (m *mockedServiceGenerator) generateServiceImplStruct() jen.Code {
	return jen.Type().
		Id(m.serviceImplStructName()).
		Struct(jen.Id("mocker").Op("*").Id(m.serviceMockerStructName()))
}

func (m *mockedServiceGenerator) serviceImplStructName() string {
	return m.serviceName + "Mocked"
}

func (m *mockedServiceGenerator) generateServiceMockerConstructor() jen.Code {
	body := m.generateServiceMockerConstructorMethodMockers()
	body = append(
		body,
		jen.Id("m").Op(":=").Op("&").Id(m.serviceMockerStructName()).Values(
			m.generateServiceMockerMockerValues()...,
		),
		jen.Id("i").Op(":=").Op("&").Id(m.serviceImplStructName()).Values(
			jen.Id("mocker").Op(":").Id("m"),
		),
		jen.Return(jen.Id("m"), jen.Id("i")),
	)
	return jen.Func().
		Id(m.serviceMockerConstructorFuncName()).
		Params(jen.Id("t").Qual("testing", "TB")).
		Params(jen.Op("*").Id(m.serviceMockerStructName()), jen.Id(m.serviceName)).
		Block(body...)
}

func (m *mockedServiceGenerator) serviceMockerConstructorFuncName() string {
	return "NewMocked" + m.serviceName
}

func (m *mockedServiceGenerator) generateServiceMockerConstructorMethodMockers() []jen.Code {
	codes := make([]jen.Code, 0, 0)
	for i, funcgen := range m.methodGenerators {
		codes = append(codes, jen.List(
			jen.Id(fmt.Sprintf("m%d", i)),
			jen.Op("_"),
		).Op(":=").Id(funcgen.mockerConstructorName()).Call(jen.Id("t")))
	}
	return codes
}

func (m *mockedServiceGenerator) generateServiceMockerMockerValues() []jen.Code {
	codes := make([]jen.Code, 0, 0)
	for i, method := range m.methods {
		codes = append(codes, jen.Id(method.Name).Op(":").Id(fmt.Sprintf("m%d", i)))
	}
	return codes
}

func (m *mockedServiceGenerator) genreateServiceMockedMethodImpls() []jen.Code {
	impls := make([]jen.Code, 0, 0)
	for i, funcgen := range m.methodGenerators {
		impls = append(
			impls,
			jen.Func().
				Params(jen.Id("m").Op("*").Id(m.serviceImplStructName())).
				Id(m.methods[i].Name).
				Params(funcgen.generateInputParamDefinitions(funcgen.ftype.IsVariadic())...).
				Params(funcgen.generateOutputParamDefinitions()...).
				Block(
					jen.Return().
						Id("m").
						Dot("mocker").
						Dot(m.methods[i].Name).
						Dot("Call").
						Call(funcgen.generateInputValues(false)...),
				),
		)
	}
	return impls
}

func GenerateMocker(typ reflect.Type, opts ...GenerateOption) error {
	switch typ.Kind() {
	case reflect.Interface:
		return GenerateServiceMocker(typ, opts...)
	case reflect.Func:
		return GenerateFunctionMocker(typ, opts...)
	default:
		return errors.New("not a function or interface")
	}
}
